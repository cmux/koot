/* eslint-disable no-console */
// jest configuration
jest.setTimeout(5 * 60 * 1 * 1000);

//

const fs = require('fs-extra');
const path = require('path');
const util = require('util');
const exec = util.promisify(require('child_process').exec);
const execSync = require('child_process').exec;
// const chalk = require('chalk')
const JSDOM = require('jsdom').JSDOM;
const puppeteer = require('puppeteer');
const chalk = require('chalk');
const postcss = require('postcss');
const cheerio = require('cheerio');

//

const {
    chunkNameExtractCss,
    chunkNameExtractCssForImport,
    buildManifestFilename,
} = require('koot/defaults/before-build');
const { KOOT_CLIENT_PUBLIC_PATH } = require('koot/defaults/envs');
const terminate = require('../../libs/terminate-process');
const waitForPort = require('../../libs/get-port-from-child-process');
const testHtmlRenderedByKoot = require('../../general-tests/html/rendered-by-koot');
const testFilesFromChunkmap = require('../../general-tests/bundle/check-files-from-chunkmap');
const checkDistRootFiles = require('../../general-tests/check-dist-root-files');
const testHtmlWebAppMetaTags = require('../../general-tests/html/web-app-meta-tags');
const {
    requestHidden404: testRequestHidden404,
    criticalAssetsShouldBeGzip: testAssetsGzip,
    clientLifecycles: testClientLifecycles,
    i18n: testI18n,
    // pageinfoOnlyMetas: puppeteerPageinfoOnlyMetas,
} = require('../puppeteer-test');

//

const removeTempProjectConfig = require('../../../packages/koot/libs/remove-temp-project-config');
const sleep = require('../../../packages/koot/utils/sleep');
const postcssTransformDeclUrls = require('../../../packages/koot-webpack/postcss/transform-decl-urls');
// const validateConfig = require('../../../packages/koot/libs/validate-config');

//

const projects = require('../../projects/get')();

const projectsToUse = projects.filter(
    (project) =>
        // Array.isArray(project.type) && project.type.includes('react-isomorphic')
        project.name === 'standard'
);
const commandTestBuild = 'koot-buildtest';
const headless = false;

//

//

/**
 * Âêë package.json ÈáåÊ∑ªÂä† npm ÂëΩ‰ª§
 * @async
 * @param {String} name
 * @param {String} command
 * @param {String} cwd
 */
const addCommand = async (name, command, cwd) => {
    const pathPackage = path.resolve(cwd, 'package.json');
    const p = await fs.readJson(pathPackage);
    // if (!p.scripts[name])
    p.scripts[name] = command;
    await fs.writeJson(pathPackage, p, {
        spaces: 4,
    });
};

/**
 * ÊµãËØïÈ°πÁõÆÂºÄÂßãÂâç
 * @async
 * @param {String} cwd Current Project Directory
 * @param {String} dist
 */
const beforeTest = async (cwd) => {
    await removeTempProjectConfig(cwd);
    await fs.remove(path.resolve(cwd, 'dist'));
    await fs.remove(path.resolve(cwd, 'logs'));
    await fs.remove(path.resolve(cwd, 'node_modules/.cache'));
};

/**
 * ÊµãËØïÈ°πÁõÆÁªìÊùüÂêé
 * @async
 * @param {String} cwd Current Project Directory
 * @param {String} dist
 * @param {String} title
 */
const afterTest = async (cwd /*, title*/) => {
    await sleep(2 * 1000);
    await removeTempProjectConfig(cwd);

    // console.log(chalk.green('‚àö ') + title)
};

//

const testFull = (dir, configFileName, issueNum) => {
    const forceChangeType = !configFileName;
    const fileKootConfig = path.resolve(
        dir,
        configFileName || 'koot.config.js'
    );
    const fileKootConfigRel = path.relative(dir, fileKootConfig);

    return describe(`üß∂ ÈÖçÁΩÆÊñá‰ª∂: ${configFileName || 'ÈªòËÆ§'}`, () => {
        const start = Date.now();
        const config = require(fileKootConfig);
        const dest = forceChangeType ? 'dist-spa-test' : config.dist;
        const dist = path.resolve(dir, dest);

        const fileIndexHtml = path.resolve(dist, 'index.html');

        if (fs.existsSync(dist)) fs.emptyDirSync(dist);
        else fs.removeSync(dist);

        test(`‰ΩøÁî® koot-build ÂëΩ‰ª§ËøõË°åÁîü‰∫ßÊ®°ÂºèÊâìÂåÖÔºåÊâìÂåÖÂ∫îËØ•ÊàêÂäü`, async () => {
            await beforeTest(dir);

            const commandName = `${commandTestBuild}-spa-build-config-${
                configFileName ? configFileName.replace(/\./g, '_') : 'default'
            }`;
            const command =
                `koot-build --koot-test` +
                (forceChangeType
                    ? ` --type react-spa --dest ${dest}`
                    : ` --config ${fileKootConfigRel}`);
            await addCommand(commandName, command, dir);

            // console.log(commandName)
            const { /*stdout,*/ stderr } = await exec(
                `npm run ${commandName}`,
                {
                    cwd: dir,
                }
            );

            // console.log(stderr)

            expect(typeof stderr).toBe('string');
            expect(
                stderr
                    .replace(
                        /\(node:([0-9]+?)\) Warning: No such label 'URL' for console.timeEnd\(\)/g,
                        ''
                    )
                    .replace(
                        /\*\* \(sharp:([0-9]+?)\): WARNING \*\*: ([0-9:.]+?): jpegsave_buffer: no property named `subsample_mode'/g,
                        ''
                    )
                    .replace(/\r/g, '')
                    .replace(/\n/g, '')
            ).toBe('');

            await afterTest(dir, '[Production] ‰ΩøÁî® koot-build ÂëΩ‰ª§ËøõË°åÊâìÂåÖ');
        });

        test(`ÊâìÂåÖÂÆåÊàêÂêéÔºåindex.html ‰∏éÁõ∏Â∫îÁöÑÈùôÊÄÅËµÑÊ∫êÊñá‰ª∂Â∫îËØ•Â≠òÂú®Ôºå‰∏îÂÜÖÂÆπÂ∫îËØ•Ê≠£Á°Æ`, async () => {
            // const config = await validateConfig(dir, {
            //     configFilename: fileKootConfig,
            // });

            // chunkmap
            const fileChunkmap = path.resolve(dist, buildManifestFilename);
            expect(fs.existsSync(fileChunkmap)).toBe(true);

            const chunkmap = fs.readJsonSync(fileChunkmap);
            expect(typeof chunkmap).toBe('object');

            const { '.files': files } = chunkmap;
            expect(typeof files).toBe('object');

            // Ê†πÊçÆ key ÊµãËØï chunkmap ‰∏≠ÁöÑÊñá‰ª∂
            const testFileFromFilelist = (key, shouldHasPublicPath = false) => {
                const pathname = files[key];
                expect(typeof pathname).toBe('string');

                const file = path.resolve(dist, pathname);
                expect(fs.existsSync(file)).toBe(true);

                const content = fs.readFileSync(file, 'utf-8');

                // ÊµãËØï CSS ÂÜÖÂÆπ
                const root = postcss.parse(content);
                const regExpPublicPath = /^includes\//g;
                postcssTransformDeclUrls(root, (url) => {
                    expect(regExpPublicPath.test(url)).toBe(
                        shouldHasPublicPath
                    );
                    return url;
                });
            };

            // ÊµãËØïÊñá‰ª∂: /index.html
            {
                expect(fs.existsSync(fileIndexHtml)).toBe(true);

                const content = fs.readFileSync(fileIndexHtml);
                const dom = new JSDOM(content);
                const config = require(path.resolve(dir, 'koot.config.js'));
                const chunkmap = fs.readJsonSync(
                    require('../../../packages/koot/utils/get-chunkmap-path')(
                        dist
                    )
                );

                expect(
                    dom.window.document.querySelector('title').textContent
                ).toBe(config.name);

                // ÊµãËØï: HTML Ê≥®ÂÖ• (Âä®ÊÄÅ)
                const checkFilename = 'specialEntry.js';
                const checkString =
                    `<!--:::KOOT:::TEST:::` +
                    chunkmap['.files'][checkFilename] +
                    fs.readFileSync(
                        path.resolve(dist, chunkmap['.files'][checkFilename]),
                        'utf-8'
                    ) +
                    `-->`;
                expect(content.includes(checkString)).toBe(true);

                if (config.webApp) await testHtmlWebAppMetaTags(content, dist);
                await testHtmlRenderedByKoot(content);
            }

            // ÊµãËØïÊñá‰ª∂: ÂÖ®Â±Ä CSS
            testFileFromFilelist(chunkNameExtractCss + '.css', true);
            testFileFromFilelist(chunkNameExtractCssForImport + '.css', false);

            await checkDistRootFiles({
                dist,
                env: 'prod',
                type: 'spa',
                serverMode: undefined,
            });
            await testFilesFromChunkmap(dist, false);
        });

        async function testServer(title, testFunc) {
            test(title, async () => {
                const fileServerJS = path.resolve(dist, './.server/index.js');
                expect(fs.existsSync(fileServerJS)).toBe(true);

                const port = config.port;
                const errors = [];

                const browser = await puppeteer.launch({
                    headless,
                });
                const context = await browser.createIncognitoBrowserContext();

                await testFunc({ cwd: dir, fileServerJS, port, browser }).catch(
                    (e) => {
                        errors.push(e);
                    }
                );
                await testFunc({
                    cwd: dist,
                    fileServerJS,
                    port,
                    browser,
                }).catch((e) => {
                    errors.push(e);
                });

                await context.close();
                await browser.close();

                if (errors.length) {
                    errors.forEach((e) => console.error(e));
                }

                expect(errors.length).toBe(0);

                if (fs.existsSync(dist)) fs.removeSync(dist);

                console.log(
                    chalk.green('‚àö ') +
                        chalk.green(`${(Date.now() - start) / 1000}s `) +
                        (configFileName || 'ÈªòËÆ§')
                );
            });
        }
        switch (issueNum) {
            case 249: {
                testServer(
                    `#249 | \`historyType === 'browser'\` ÂêåÊó∂ËÆæÂÆö‰∫Ü Webpack ÁöÑ \`output.publicPath\` Êó∂ÔºåÂêéËÄÖÊó†Êïà`,
                    async ({ cwd, port, fileServerJS, browser }) => {
                        // console.log({
                        //     command: `node ${fileServerJS}`,
                        //     cwd
                        // });
                        const child = execSync(`node ${fileServerJS}`, {
                            cwd,
                        });
                        const errors = [];
                        child.stderr.on('data', (err) => {
                            errors.push(err);
                        });

                        await waitForPort(child);

                        const origin = isNaN(port)
                            ? port
                            : `http://127.0.0.1:${port}`;
                        const context =
                            await browser.createIncognitoBrowserContext();
                        const page = await context.newPage();
                        const failedResponse = [];
                        require('../../libs/puppeteer/page-event-response-failed-response')(
                            page,
                            failedResponse
                        );

                        const res = await page.goto(origin, {
                            waitUntil: 'load',
                        });
                        const html = await res.text();
                        const $ = cheerio.load(html);
                        const checkRegExp = new RegExp(
                            `^${config[KOOT_CLIENT_PUBLIC_PATH]}`
                        );
                        for (const s of $('script[src][data-koot-entry]')) {
                            // console.log(s.attribs.src);
                            const src = s.attribs.src;
                            if (src)
                                expect(checkRegExp.test(s.attribs.src)).toBe(
                                    true
                                );
                        }

                        await page.close();
                        await context.close();

                        // ÊµãËØï: Ê≤°ÊúâÂ§±Ë¥•ÁöÑËØ∑Ê±Ç
                        if (failedResponse.length) {
                            console.log(
                                'failedResponse',
                                failedResponse.map((res) => ({
                                    status: res.status(),
                                    url: res.url(),
                                }))
                            );
                        }
                        expect(failedResponse.length).toBe(0);
                        if (errors.length) {
                            errors.forEach((e) => console.error(e));
                        }
                        expect(errors.length).toBe(0);

                        // ÁªìÊùüÊµãËØï
                        await terminate(child.pid);
                    }
                );
                break;
            }
            default:
                testServer(
                    `[prod] ÁÆÄÊòìÊúçÂä°Âô®ÂèØÁî® & JS ÊâßË°åÊ≠£Á°Æ`,
                    async ({ cwd, port, fileServerJS, browser }) => {
                        // console.log({
                        //     command: `node ${fileServerJS}`,
                        //     cwd
                        // });
                        const child = execSync(`node ${fileServerJS}`, {
                            cwd,
                        });
                        const errors = [];
                        child.stderr.on('data', (err) => {
                            errors.push(err);
                        });

                        await waitForPort(child);

                        const origin = isNaN(port)
                            ? port
                            : `http://127.0.0.1:${port}`;
                        const context =
                            await browser.createIncognitoBrowserContext();
                        const page = await context.newPage();
                        const failedResponse = [];
                        require('../../libs/puppeteer/page-event-response-failed-response')(
                            page,
                            failedResponse
                        );

                        const res = await page.goto(origin, {
                            waitUntil: 'load',
                        });
                        const html = await res.text();

                        await testHtmlRenderedByKoot(html);
                        await testRequestHidden404(origin, browser);
                        await testAssetsGzip(origin, dist);
                        await testClientLifecycles(origin, browser);
                        // await puppeteerPageinfoOnlyMetas({
                        //     origin,
                        //     browser,
                        //     isSPA: true,
                        // });

                        await page.goto(origin + '/#/static');

                        await page.close();
                        await context.close();

                        // ÊµãËØï: Ê≤°ÊúâÂ§±Ë¥•ÁöÑËØ∑Ê±Ç
                        if (failedResponse.length) {
                            console.log(
                                'failedResponse',
                                failedResponse.map((res) => ({
                                    status: res.status(),
                                    url: res.url(),
                                }))
                            );
                        }
                        expect(failedResponse.length).toBe(0);
                        if (errors.length) {
                            errors.forEach((e) => console.error(e));
                        }
                        expect(errors.length).toBe(0);

                        // ÊµãËØï: Â§öËØ≠Ë®Ä
                        if (config.i18n) {
                            await testI18n({
                                browser,
                                origin,
                                i18n: config.i18n,
                                isDev: false,
                                isSPA: true,
                                cwd: dir,
                                dist,
                            });
                        }

                        // TODO: Âú®ËÆæÁΩÆ‰∫Ü sw Êó∂Êúâ sw Ê≥®ÂÜå‰∏îÊ≤°ÊúâÊä•Èîô

                        // ÁªìÊùüÊµãËØï
                        await terminate(child.pid);
                    }
                );
        }

        // TODO: ÊµãËØï: ÊâÄÊúâ Webpack ÁªìÊûúËµÑÊ∫êÁöÑËÆøÈóÆ

        // TODO: ÊµãËØï: extend connect ÁöÑ Array Áî®Ê≥ï
    });
};

describe('ÊµãËØï: React SPA È°πÁõÆ', () => {
    for (const project of projectsToUse) {
        const { name, dir } = project;
        describe(`È°πÁõÆ: ${name}`, () => {
            testFull(dir);
            testFull(dir, 'koot.build.spa-1.js');
            testFull(dir, 'koot.build.spa-2.js');
            testFull(dir, 'koot.build.spa-3.js');
            testFull(dir, 'koot.build.spa-#249.js', 249);
        });
    }
});

// TODO: ÂºÄÂèëÁéØÂ¢É

/** TODO: ÁÉ≠Êõ¥Êñ∞ÊµãËØï
 * - ‰øÆÊîπ ejs
 * - ‰øÆÊîπ css
 * - ‰øÆÊîπ react ÁªÑ‰ª∂
 * - ‰øÆÊîπ extend ‰º†ÂÖ•‰ø°ÊÅØ
 */
